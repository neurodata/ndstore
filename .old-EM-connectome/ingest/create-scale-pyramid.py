# Copyright 2014 NeuroData (http://neurodata.io)
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

#!/usr/bin/python

#
# Use the full-resolution tiles generated by create-tiles.py and produce
# a complete binary "scale pyramid". 
#
# Each new tile is generated from 4 existing tiles.  The process is run
# iteratively until the entire image is represented in a single tile.
#
# This version of the code contains a minor modification to prefetch all
# tiles needed to convert a single column of data.  While the code is
# messier, the performance more than doubles.
#


import argparse
import errno
import math
import os
import re
import sys

import Image

class DataInfo:
    srcwidth=5200
    srcheight=5200
    outwidth=256
    outheight=256
    root = None
    rows = 23
    cols = 26
    maxscale = 10       # Maximum scale to reduce to

    def __init__(self):
        pass

    def fullWidthInPixels(self):
        return self.cols * self.imagewidth

    def fullHeightInPixels(self):
        return self.cols * self.imagewidth

    def getFileLocation(self, scale, col, row):
        return "{0}/{1}/{2}/{3}_{4}.png".format(self.root, scale, self.slice, row, col)

    def makeDirs(self,scale):
        dir = "{0}/{1}/{2}/".format(self.root, scale, self.slice)
        try:
            os.makedirs(dir)
        except os.error, e:
            pass

    def tileCountAtScale(self, scale):
        fwidth = float(self.srcwidth * self.cols)
        fheight = float(self.srcheight * self.rows)
        height = int(math.ceil(fheight / float(self.outheight * math.pow(2,scale) )))
        width = int(math.ceil(fwidth / float(self.outwidth * math.pow(2,scale) )))
        return (height,width)

def main():
    parser = argparse.ArgumentParser(description="Create scale pyramid")
    parser.add_argument('root', action="store", help="Root data directory (do not include '/0')")
    parser.add_argument('slice', action="store", type=int,  help="Slice to convert (int)")

    args = parser.parse_args()

    data = DataInfo()
    data.root= args.root
    data.slice = args.slice

    for scale in xrange(1, data.maxscale+1):
        data.makeDirs(scale)
        print("Converting images from for scale {0}".format(scale))
        (scalerows, scalecols) = data.tileCountAtScale(scale)
        (prevscalerows, prevscalecols) = data.tileCountAtScale(scale - 1)
        print  data.tileCountAtScale(scale)
        print  data.tileCountAtScale(scale-1)
        for col in xrange(scalecols):   
            # Open every image in a column at once... 
            # This is a minor optimization to try to alternate reads & writes
            images = {}
            for row in xrange(scalerows):
                for r in xrange(2):
                    srcrow = row * 2 + r
                    if srcrow == prevscalerows:
                        # Past the edge
                        continue
                    for c in xrange(2):
                        srccol = col * 2 + c
                        if srccol == prevscalecols:
                            # Past the edge
                            continue
                        infile = data.getFileLocation(scale - 1, srccol, srcrow)
                        images[(srccol, srcrow)] = Image.open(infile)
                        images[(srccol, srcrow)].load()

            for row in xrange(scalerows):
                # New tile.  Default to black in case subtiles do not exist.
                tile = Image.new("L", (256*2,256*2) )
                outfile = data.getFileLocation(scale, col, row)
                print "Making outfile..." + outfile
                for r in xrange(2):
                    srcrow = row * 2 + r
                    if srcrow == prevscalerows:
                        # Past the edge
                        continue
                    for c in xrange(2):
                        srccol = col * 2 + c
                        if srccol == prevscalecols:
                            # Past the edge
                            continue
                        fimg = images[(srccol, srcrow)]
                        tile.paste(fimg, (256*c,256*r))
                tile.resize( (256,256), Image.BILINEAR).save(outfile, format="PNG", optimize=1)
            images.clear()

if __name__ == "__main__":
    main()
